Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Описание

Для реализации интерфейса FloodControl написал структуру FloodController, которая имплементирует нужный нам интерфейс. <br>
Данная структура имеет 4 поля - client, collection, N и K. Решил сделать все поля скрытыми от клиента, во избежание "А что если" со стороны любознательного разработчика, поэтому помимо функции Check() написал еще функцию для отключения. <br>
В качестве базы данных выбрал MongoDB, как из-за малого количества полей, простой структуры данных, отсутсвия явной в данной задаче взаимосвязи с другими данными, а также постоянным обновлением поля lastCallTime и меньшим объемом занимаемемой памяти в долгосрочной перспективе. Из-за этих причин также отказался от использования каких-либо реляционных баз данных.<br>
Еще одним вариантом было in-memory хранение, например создание структы Store с мапой внутри, но этот вариант сразу отбросил из-за снижения производительности за счет мьютексов а также невозможности восстановить данные после падения сервиса.<br>
Так же рассматривал вариант базы данных - Redis, но посчитал, что в случае добавления каких-либо новых условий для провекри на флуд лучше подойдет документоориентированная база данных.<br>
